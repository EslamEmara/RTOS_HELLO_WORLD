
RTOS_LAB1_ATMEGA32.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000c4a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000014  00800060  00000c4a  00000cde  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002bd  00800074  00800074  00000cf2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000cf2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000d24  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000200  00000000  00000000  00000d60  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000023f4  00000000  00000000  00000f60  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000dbf  00000000  00000000  00003354  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001390  00000000  00000000  00004113  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000558  00000000  00000000  000054a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000c98  00000000  00000000  000059fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000018b5  00000000  00000000  00006694  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001d0  00000000  00000000  00007f49  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 55 02 	jmp	0x4aa	; 0x4aa <__vector_7>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ea e4       	ldi	r30, 0x4A	; 74
  68:	fc e0       	ldi	r31, 0x0C	; 12
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a4 37       	cpi	r26, 0x74	; 116
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	23 e0       	ldi	r18, 0x03	; 3
  78:	a4 e7       	ldi	r26, 0x74	; 116
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a1 33       	cpi	r26, 0x31	; 49
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 bc 02 	call	0x578	; 0x578 <main>
  8a:	0c 94 23 06 	jmp	0xc46	; 0xc46 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  92:	cf 93       	push	r28
  94:	df 93       	push	r29
  96:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
  98:	0e 94 20 04 	call	0x840	; 0x840 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
  9c:	20 91 74 00 	lds	r18, 0x0074	; 0x800074 <__data_end>
  a0:	30 91 75 00 	lds	r19, 0x0075	; 0x800075 <__data_end+0x1>
  a4:	c9 01       	movw	r24, r18
  a6:	8c 0f       	add	r24, r28
  a8:	9d 1f       	adc	r25, r29
  aa:	88 35       	cpi	r24, 0x58	; 88
  ac:	42 e0       	ldi	r20, 0x02	; 2
  ae:	94 07       	cpc	r25, r20
  b0:	58 f4       	brcc	.+22     	; 0xc8 <pvPortMalloc+0x36>
  b2:	28 17       	cp	r18, r24
  b4:	39 07       	cpc	r19, r25
  b6:	58 f4       	brcc	.+22     	; 0xce <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
  b8:	e9 01       	movw	r28, r18
  ba:	ca 58       	subi	r28, 0x8A	; 138
  bc:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
  be:	90 93 75 00 	sts	0x0075, r25	; 0x800075 <__data_end+0x1>
  c2:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__data_end>
  c6:	05 c0       	rjmp	.+10     	; 0xd2 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
  c8:	c0 e0       	ldi	r28, 0x00	; 0
  ca:	d0 e0       	ldi	r29, 0x00	; 0
  cc:	02 c0       	rjmp	.+4      	; 0xd2 <pvPortMalloc+0x40>
  ce:	c0 e0       	ldi	r28, 0x00	; 0
  d0:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
  d2:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
  d6:	ce 01       	movw	r24, r28
  d8:	df 91       	pop	r29
  da:	cf 91       	pop	r28
  dc:	08 95       	ret

000000de <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  de:	08 95       	ret

000000e0 <enableTrigger>:
//   data changes.
////////////////////////////////////////////////////////////////////
void enableTrigger(void)
{

	CLR_BIT(PORTB,2);
  e0:	c2 98       	cbi	0x18, 2	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  e2:	89 ef       	ldi	r24, 0xF9	; 249
  e4:	90 e0       	ldi	r25, 0x00	; 0
  e6:	01 97       	sbiw	r24, 0x01	; 1
  e8:	f1 f7       	brne	.-4      	; 0xe6 <enableTrigger+0x6>
  ea:	00 c0       	rjmp	.+0      	; 0xec <enableTrigger+0xc>
  ec:	00 00       	nop
	
	_delay_ms(1);

	SET_BIT(PORTB,2);
  ee:	c2 9a       	sbi	0x18, 2	; 24
  f0:	8b ed       	ldi	r24, 0xDB	; 219
  f2:	95 e0       	ldi	r25, 0x05	; 5
  f4:	01 97       	sbiw	r24, 0x01	; 1
  f6:	f1 f7       	brne	.-4      	; 0xf4 <enableTrigger+0x14>
  f8:	00 c0       	rjmp	.+0      	; 0xfa <enableTrigger+0x1a>
  fa:	00 00       	nop
  fc:	08 95       	ret

000000fe <lcd_sendCommand>:
		
}


void lcd_sendCommand(unsigned char cmd)
{
  fe:	cf 93       	push	r28
 100:	c8 2f       	mov	r28, r24
	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
	LOW_NIBBLE(low_nibble,cmd);

	CLR_BIT(PORTB,0); // to enable command mode 
 102:	c0 98       	cbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // write signal to lcd 
 104:	c1 98       	cbi	0x18, 1	; 24

	PORTB &=0x0f;
 106:	88 b3       	in	r24, 0x18	; 24
 108:	8f 70       	andi	r24, 0x0F	; 15
 10a:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble command  
 10c:	88 b3       	in	r24, 0x18	; 24
 10e:	9c 2f       	mov	r25, r28
 110:	90 7f       	andi	r25, 0xF0	; 240
 112:	89 2b       	or	r24, r25
 114:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
 116:	0e 94 70 00 	call	0xe0	; 0xe0 <enableTrigger>

	PORTB &=0x0f;
 11a:	88 b3       	in	r24, 0x18	; 24
 11c:	8f 70       	andi	r24, 0x0F	; 15
 11e:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble command 
 120:	88 b3       	in	r24, 0x18	; 24
 122:	c2 95       	swap	r28
 124:	c0 7f       	andi	r28, 0xF0	; 240
 126:	c8 2b       	or	r28, r24
 128:	c8 bb       	out	0x18, r28	; 24
	enableTrigger();
 12a:	0e 94 70 00 	call	0xe0	; 0xe0 <enableTrigger>

}
 12e:	cf 91       	pop	r28
 130:	08 95       	ret

00000132 <lcd_init>:
//							 and pinB.0 to pinB.2 o/p for control pins 
//////////////////////////////////////////////////////////////////////////////////////
void lcd_init(void)
{

	DDRB=0xff; // init port B as O/P port 
 132:	8f ef       	ldi	r24, 0xFF	; 255
 134:	87 bb       	out	0x17, r24	; 23
	PORTB=0x04; // activate LCD enable 
 136:	84 e0       	ldi	r24, 0x04	; 4
 138:	88 bb       	out	0x18, r24	; 24

	lcd_sendCommand(0x33); // 4-bit mode 
 13a:	83 e3       	ldi	r24, 0x33	; 51
 13c:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>
	lcd_sendCommand (0x32);
 140:	82 e3       	ldi	r24, 0x32	; 50
 142:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>
	lcd_sendCommand (0x28);
 146:	88 e2       	ldi	r24, 0x28	; 40
 148:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>



	lcd_sendCommand(0x0c); // turn on lcd 
 14c:	8c e0       	ldi	r24, 0x0C	; 12
 14e:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>
 152:	08 95       	ret

00000154 <lcd_displayChar>:
	enableTrigger();

}

void lcd_displayChar (unsigned char data)
{
 154:	cf 93       	push	r28
 156:	c8 2f       	mov	r28, r24

	unsigned char high_nibble , low_nibble ;

	SET_BIT(PORTB,0); //  enable data mode 
 158:	c0 9a       	sbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // activate lcd write 
 15a:	c1 98       	cbi	0x18, 1	; 24

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
	
	PORTB &= 0x0f;
 15c:	88 b3       	in	r24, 0x18	; 24
 15e:	8f 70       	andi	r24, 0x0F	; 15
 160:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble data  
 162:	88 b3       	in	r24, 0x18	; 24
 164:	9c 2f       	mov	r25, r28
 166:	90 7f       	andi	r25, 0xF0	; 240
 168:	89 2b       	or	r24, r25
 16a:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
 16c:	0e 94 70 00 	call	0xe0	; 0xe0 <enableTrigger>
	
	PORTB &=0x0f;
 170:	88 b3       	in	r24, 0x18	; 24
 172:	8f 70       	andi	r24, 0x0F	; 15
 174:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble data 
 176:	88 b3       	in	r24, 0x18	; 24
 178:	c2 95       	swap	r28
 17a:	c0 7f       	andi	r28, 0xF0	; 240
 17c:	c8 2b       	or	r28, r24
 17e:	c8 bb       	out	0x18, r28	; 24
	enableTrigger();
 180:	0e 94 70 00 	call	0xe0	; 0xe0 <enableTrigger>
	

}
 184:	cf 91       	pop	r28
 186:	08 95       	ret

00000188 <lcd_gotoxy>:

void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
	 
	switch(y)
 188:	81 30       	cpi	r24, 0x01	; 1
 18a:	49 f0       	breq	.+18     	; 0x19e <lcd_gotoxy+0x16>
 18c:	28 f0       	brcs	.+10     	; 0x198 <lcd_gotoxy+0x10>
 18e:	82 30       	cpi	r24, 0x02	; 2
 190:	49 f0       	breq	.+18     	; 0x1a4 <lcd_gotoxy+0x1c>
 192:	83 30       	cpi	r24, 0x03	; 3
 194:	51 f0       	breq	.+20     	; 0x1aa <lcd_gotoxy+0x22>
 196:	0c c0       	rjmp	.+24     	; 0x1b0 <lcd_gotoxy+0x28>
	{
		case 0:

			position=position+x;
 198:	80 e8       	ldi	r24, 0x80	; 128
 19a:	86 0f       	add	r24, r22
					
		break;
 19c:	0a c0       	rjmp	.+20     	; 0x1b2 <lcd_gotoxy+0x2a>

		case 1:

			position=0xc0;
			position=position+x;
 19e:	80 ec       	ldi	r24, 0xC0	; 192
 1a0:	86 0f       	add	r24, r22

		break;
 1a2:	07 c0       	rjmp	.+14     	; 0x1b2 <lcd_gotoxy+0x2a>

		case 2:

			position=position+x;
 1a4:	80 e8       	ldi	r24, 0x80	; 128
 1a6:	86 0f       	add	r24, r22

		break;
 1a8:	04 c0       	rjmp	.+8      	; 0x1b2 <lcd_gotoxy+0x2a>

		case 3:
			position=position+x;
 1aa:	80 e8       	ldi	r24, 0x80	; 128
 1ac:	86 0f       	add	r24, r22
		break;
 1ae:	01 c0       	rjmp	.+2      	; 0x1b2 <lcd_gotoxy+0x2a>
}


void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
 1b0:	80 e8       	ldi	r24, 0x80	; 128
		break;
	
	
	}
	
	lcd_sendCommand(position); 	
 1b2:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>
 1b6:	08 95       	ret

000001b8 <lcd_clrScreen>:


void lcd_clrScreen(void)
{

	lcd_sendCommand(0x01);
 1b8:	81 e0       	ldi	r24, 0x01	; 1
 1ba:	0e 94 7f 00 	call	0xfe	; 0xfe <lcd_sendCommand>
 1be:	08 95       	ret

000001c0 <lcd_dispString>:

}


void lcd_dispString(char * ptr)
{
 1c0:	cf 93       	push	r28
 1c2:	df 93       	push	r29
 1c4:	ec 01       	movw	r28, r24

	while(* ptr!= '\0')
 1c6:	88 81       	ld	r24, Y
 1c8:	88 23       	and	r24, r24
 1ca:	31 f0       	breq	.+12     	; 0x1d8 <lcd_dispString+0x18>
 1cc:	21 96       	adiw	r28, 0x01	; 1
	{
		lcd_displayChar(* ptr);
 1ce:	0e 94 aa 00 	call	0x154	; 0x154 <lcd_displayChar>


void lcd_dispString(char * ptr)
{

	while(* ptr!= '\0')
 1d2:	89 91       	ld	r24, Y+
 1d4:	81 11       	cpse	r24, r1
 1d6:	fb cf       	rjmp	.-10     	; 0x1ce <lcd_dispString+0xe>
	
	}



}
 1d8:	df 91       	pop	r29
 1da:	cf 91       	pop	r28
 1dc:	08 95       	ret

000001de <lcd_disp_string_xy>:

void lcd_disp_string_xy(char * ptr , int y , int x)
{
 1de:	cf 93       	push	r28
 1e0:	df 93       	push	r29
 1e2:	ec 01       	movw	r28, r24
 1e4:	86 2f       	mov	r24, r22

	lcd_gotoxy(y,x);
 1e6:	64 2f       	mov	r22, r20
 1e8:	0e 94 c4 00 	call	0x188	; 0x188 <lcd_gotoxy>
	lcd_dispString(ptr);
 1ec:	ce 01       	movw	r24, r28
 1ee:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <lcd_dispString>

	


}
 1f2:	df 91       	pop	r29
 1f4:	cf 91       	pop	r28
 1f6:	08 95       	ret

000001f8 <vListInitialise>:
	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
}
 1f8:	fc 01       	movw	r30, r24
 1fa:	03 96       	adiw	r24, 0x03	; 3
 1fc:	92 83       	std	Z+2, r25	; 0x02
 1fe:	81 83       	std	Z+1, r24	; 0x01
 200:	2f ef       	ldi	r18, 0xFF	; 255
 202:	3f ef       	ldi	r19, 0xFF	; 255
 204:	34 83       	std	Z+4, r19	; 0x04
 206:	23 83       	std	Z+3, r18	; 0x03
 208:	96 83       	std	Z+6, r25	; 0x06
 20a:	85 83       	std	Z+5, r24	; 0x05
 20c:	90 87       	std	Z+8, r25	; 0x08
 20e:	87 83       	std	Z+7, r24	; 0x07
 210:	10 82       	st	Z, r1
 212:	08 95       	ret

00000214 <vListInitialiseItem>:
 214:	fc 01       	movw	r30, r24
 216:	11 86       	std	Z+9, r1	; 0x09
 218:	10 86       	std	Z+8, r1	; 0x08
 21a:	08 95       	ret

0000021c <vListInsertEnd>:
 21c:	cf 93       	push	r28
 21e:	df 93       	push	r29
 220:	fc 01       	movw	r30, r24
 222:	db 01       	movw	r26, r22
 224:	21 81       	ldd	r18, Z+1	; 0x01
 226:	32 81       	ldd	r19, Z+2	; 0x02
 228:	e9 01       	movw	r28, r18
 22a:	8a 81       	ldd	r24, Y+2	; 0x02
 22c:	9b 81       	ldd	r25, Y+3	; 0x03
 22e:	13 96       	adiw	r26, 0x03	; 3
 230:	9c 93       	st	X, r25
 232:	8e 93       	st	-X, r24
 234:	12 97       	sbiw	r26, 0x02	; 2
 236:	81 81       	ldd	r24, Z+1	; 0x01
 238:	92 81       	ldd	r25, Z+2	; 0x02
 23a:	15 96       	adiw	r26, 0x05	; 5
 23c:	9c 93       	st	X, r25
 23e:	8e 93       	st	-X, r24
 240:	14 97       	sbiw	r26, 0x04	; 4
 242:	8a 81       	ldd	r24, Y+2	; 0x02
 244:	9b 81       	ldd	r25, Y+3	; 0x03
 246:	ec 01       	movw	r28, r24
 248:	7d 83       	std	Y+5, r23	; 0x05
 24a:	6c 83       	std	Y+4, r22	; 0x04
 24c:	e9 01       	movw	r28, r18
 24e:	7b 83       	std	Y+3, r23	; 0x03
 250:	6a 83       	std	Y+2, r22	; 0x02
 252:	72 83       	std	Z+2, r23	; 0x02
 254:	61 83       	std	Z+1, r22	; 0x01
 256:	19 96       	adiw	r26, 0x09	; 9
 258:	fc 93       	st	X, r31
 25a:	ee 93       	st	-X, r30
 25c:	18 97       	sbiw	r26, 0x08	; 8
 25e:	80 81       	ld	r24, Z
 260:	8f 5f       	subi	r24, 0xFF	; 255
 262:	80 83       	st	Z, r24
 264:	df 91       	pop	r29
 266:	cf 91       	pop	r28
 268:	08 95       	ret

0000026a <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 26a:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 26c:	a2 81       	ldd	r26, Z+2	; 0x02
 26e:	b3 81       	ldd	r27, Z+3	; 0x03
 270:	84 81       	ldd	r24, Z+4	; 0x04
 272:	95 81       	ldd	r25, Z+5	; 0x05
 274:	15 96       	adiw	r26, 0x05	; 5
 276:	9c 93       	st	X, r25
 278:	8e 93       	st	-X, r24
 27a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 27c:	a4 81       	ldd	r26, Z+4	; 0x04
 27e:	b5 81       	ldd	r27, Z+5	; 0x05
 280:	82 81       	ldd	r24, Z+2	; 0x02
 282:	93 81       	ldd	r25, Z+3	; 0x03
 284:	13 96       	adiw	r26, 0x03	; 3
 286:	9c 93       	st	X, r25
 288:	8e 93       	st	-X, r24
 28a:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 28c:	a0 85       	ldd	r26, Z+8	; 0x08
 28e:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 290:	11 96       	adiw	r26, 0x01	; 1
 292:	8d 91       	ld	r24, X+
 294:	9c 91       	ld	r25, X
 296:	12 97       	sbiw	r26, 0x02	; 2
 298:	e8 17       	cp	r30, r24
 29a:	f9 07       	cpc	r31, r25
 29c:	31 f4       	brne	.+12     	; 0x2aa <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 29e:	84 81       	ldd	r24, Z+4	; 0x04
 2a0:	95 81       	ldd	r25, Z+5	; 0x05
 2a2:	12 96       	adiw	r26, 0x02	; 2
 2a4:	9c 93       	st	X, r25
 2a6:	8e 93       	st	-X, r24
 2a8:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
 2aa:	11 86       	std	Z+9, r1	; 0x09
 2ac:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 2ae:	8c 91       	ld	r24, X
 2b0:	81 50       	subi	r24, 0x01	; 1
 2b2:	8c 93       	st	X, r24
 2b4:	08 95       	ret

000002b6 <pxPortInitialiseStack>:
	portSAVE_CONTEXT();
	vTaskIncrementTick();
	vTaskSwitchContext();
	portRESTORE_CONTEXT();

	asm volatile ( "ret" );
 2b6:	31 e1       	ldi	r19, 0x11	; 17
 2b8:	fc 01       	movw	r30, r24
 2ba:	30 83       	st	Z, r19
 2bc:	31 97       	sbiw	r30, 0x01	; 1
 2be:	22 e2       	ldi	r18, 0x22	; 34
 2c0:	20 83       	st	Z, r18
 2c2:	31 97       	sbiw	r30, 0x01	; 1
 2c4:	a3 e3       	ldi	r26, 0x33	; 51
 2c6:	a0 83       	st	Z, r26
 2c8:	31 97       	sbiw	r30, 0x01	; 1
 2ca:	60 83       	st	Z, r22
 2cc:	31 97       	sbiw	r30, 0x01	; 1
 2ce:	70 83       	st	Z, r23
 2d0:	31 97       	sbiw	r30, 0x01	; 1
 2d2:	10 82       	st	Z, r1
 2d4:	31 97       	sbiw	r30, 0x01	; 1
 2d6:	60 e8       	ldi	r22, 0x80	; 128
 2d8:	60 83       	st	Z, r22
 2da:	31 97       	sbiw	r30, 0x01	; 1
 2dc:	10 82       	st	Z, r1
 2de:	31 97       	sbiw	r30, 0x01	; 1
 2e0:	62 e0       	ldi	r22, 0x02	; 2
 2e2:	60 83       	st	Z, r22
 2e4:	31 97       	sbiw	r30, 0x01	; 1
 2e6:	63 e0       	ldi	r22, 0x03	; 3
 2e8:	60 83       	st	Z, r22
 2ea:	31 97       	sbiw	r30, 0x01	; 1
 2ec:	64 e0       	ldi	r22, 0x04	; 4
 2ee:	60 83       	st	Z, r22
 2f0:	31 97       	sbiw	r30, 0x01	; 1
 2f2:	65 e0       	ldi	r22, 0x05	; 5
 2f4:	60 83       	st	Z, r22
 2f6:	31 97       	sbiw	r30, 0x01	; 1
 2f8:	66 e0       	ldi	r22, 0x06	; 6
 2fa:	60 83       	st	Z, r22
 2fc:	31 97       	sbiw	r30, 0x01	; 1
 2fe:	67 e0       	ldi	r22, 0x07	; 7
 300:	60 83       	st	Z, r22
 302:	31 97       	sbiw	r30, 0x01	; 1
 304:	68 e0       	ldi	r22, 0x08	; 8
 306:	60 83       	st	Z, r22
 308:	31 97       	sbiw	r30, 0x01	; 1
 30a:	69 e0       	ldi	r22, 0x09	; 9
 30c:	60 83       	st	Z, r22
 30e:	31 97       	sbiw	r30, 0x01	; 1
 310:	60 e1       	ldi	r22, 0x10	; 16
 312:	60 83       	st	Z, r22
 314:	31 97       	sbiw	r30, 0x01	; 1
 316:	30 83       	st	Z, r19
 318:	31 97       	sbiw	r30, 0x01	; 1
 31a:	32 e1       	ldi	r19, 0x12	; 18
 31c:	30 83       	st	Z, r19
 31e:	31 97       	sbiw	r30, 0x01	; 1
 320:	33 e1       	ldi	r19, 0x13	; 19
 322:	30 83       	st	Z, r19
 324:	31 97       	sbiw	r30, 0x01	; 1
 326:	34 e1       	ldi	r19, 0x14	; 20
 328:	30 83       	st	Z, r19
 32a:	31 97       	sbiw	r30, 0x01	; 1
 32c:	35 e1       	ldi	r19, 0x15	; 21
 32e:	30 83       	st	Z, r19
 330:	31 97       	sbiw	r30, 0x01	; 1
 332:	36 e1       	ldi	r19, 0x16	; 22
 334:	30 83       	st	Z, r19
 336:	31 97       	sbiw	r30, 0x01	; 1
 338:	37 e1       	ldi	r19, 0x17	; 23
 33a:	30 83       	st	Z, r19
 33c:	31 97       	sbiw	r30, 0x01	; 1
 33e:	38 e1       	ldi	r19, 0x18	; 24
 340:	30 83       	st	Z, r19
 342:	31 97       	sbiw	r30, 0x01	; 1
 344:	39 e1       	ldi	r19, 0x19	; 25
 346:	30 83       	st	Z, r19
 348:	31 97       	sbiw	r30, 0x01	; 1
 34a:	30 e2       	ldi	r19, 0x20	; 32
 34c:	30 83       	st	Z, r19
 34e:	31 97       	sbiw	r30, 0x01	; 1
 350:	31 e2       	ldi	r19, 0x21	; 33
 352:	30 83       	st	Z, r19
 354:	31 97       	sbiw	r30, 0x01	; 1
 356:	20 83       	st	Z, r18
 358:	31 97       	sbiw	r30, 0x01	; 1
 35a:	23 e2       	ldi	r18, 0x23	; 35
 35c:	20 83       	st	Z, r18
 35e:	31 97       	sbiw	r30, 0x01	; 1
 360:	40 83       	st	Z, r20
 362:	31 97       	sbiw	r30, 0x01	; 1
 364:	50 83       	st	Z, r21
 366:	31 97       	sbiw	r30, 0x01	; 1
 368:	26 e2       	ldi	r18, 0x26	; 38
 36a:	20 83       	st	Z, r18
 36c:	31 97       	sbiw	r30, 0x01	; 1
 36e:	27 e2       	ldi	r18, 0x27	; 39
 370:	20 83       	st	Z, r18
 372:	31 97       	sbiw	r30, 0x01	; 1
 374:	28 e2       	ldi	r18, 0x28	; 40
 376:	20 83       	st	Z, r18
 378:	31 97       	sbiw	r30, 0x01	; 1
 37a:	29 e2       	ldi	r18, 0x29	; 41
 37c:	20 83       	st	Z, r18
 37e:	31 97       	sbiw	r30, 0x01	; 1
 380:	20 e3       	ldi	r18, 0x30	; 48
 382:	20 83       	st	Z, r18
 384:	31 97       	sbiw	r30, 0x01	; 1
 386:	21 e3       	ldi	r18, 0x31	; 49
 388:	20 83       	st	Z, r18
 38a:	86 97       	sbiw	r24, 0x26	; 38
 38c:	08 95       	ret

0000038e <xPortStartScheduler>:
 38e:	1b bc       	out	0x2b, r1	; 43
 390:	8c e7       	ldi	r24, 0x7C	; 124
 392:	8a bd       	out	0x2a, r24	; 42
 394:	8b e0       	ldi	r24, 0x0B	; 11
 396:	8e bd       	out	0x2e, r24	; 46
 398:	89 b7       	in	r24, 0x39	; 57
 39a:	80 61       	ori	r24, 0x10	; 16
 39c:	89 bf       	out	0x39, r24	; 57
 39e:	a0 91 2f 03 	lds	r26, 0x032F	; 0x80032f <pxCurrentTCB>
 3a2:	b0 91 30 03 	lds	r27, 0x0330	; 0x800330 <pxCurrentTCB+0x1>
 3a6:	cd 91       	ld	r28, X+
 3a8:	cd bf       	out	0x3d, r28	; 61
 3aa:	dd 91       	ld	r29, X+
 3ac:	de bf       	out	0x3e, r29	; 62
 3ae:	ff 91       	pop	r31
 3b0:	ef 91       	pop	r30
 3b2:	df 91       	pop	r29
 3b4:	cf 91       	pop	r28
 3b6:	bf 91       	pop	r27
 3b8:	af 91       	pop	r26
 3ba:	9f 91       	pop	r25
 3bc:	8f 91       	pop	r24
 3be:	7f 91       	pop	r23
 3c0:	6f 91       	pop	r22
 3c2:	5f 91       	pop	r21
 3c4:	4f 91       	pop	r20
 3c6:	3f 91       	pop	r19
 3c8:	2f 91       	pop	r18
 3ca:	1f 91       	pop	r17
 3cc:	0f 91       	pop	r16
 3ce:	ff 90       	pop	r15
 3d0:	ef 90       	pop	r14
 3d2:	df 90       	pop	r13
 3d4:	cf 90       	pop	r12
 3d6:	bf 90       	pop	r11
 3d8:	af 90       	pop	r10
 3da:	9f 90       	pop	r9
 3dc:	8f 90       	pop	r8
 3de:	7f 90       	pop	r7
 3e0:	6f 90       	pop	r6
 3e2:	5f 90       	pop	r5
 3e4:	4f 90       	pop	r4
 3e6:	3f 90       	pop	r3
 3e8:	2f 90       	pop	r2
 3ea:	1f 90       	pop	r1
 3ec:	0f 90       	pop	r0
 3ee:	0f be       	out	0x3f, r0	; 63
 3f0:	0f 90       	pop	r0
 3f2:	08 95       	ret
 3f4:	81 e0       	ldi	r24, 0x01	; 1
 3f6:	08 95       	ret

000003f8 <vPortYield>:
 3f8:	0f 92       	push	r0
 3fa:	0f b6       	in	r0, 0x3f	; 63
 3fc:	f8 94       	cli
 3fe:	0f 92       	push	r0
 400:	1f 92       	push	r1
 402:	11 24       	eor	r1, r1
 404:	2f 92       	push	r2
 406:	3f 92       	push	r3
 408:	4f 92       	push	r4
 40a:	5f 92       	push	r5
 40c:	6f 92       	push	r6
 40e:	7f 92       	push	r7
 410:	8f 92       	push	r8
 412:	9f 92       	push	r9
 414:	af 92       	push	r10
 416:	bf 92       	push	r11
 418:	cf 92       	push	r12
 41a:	df 92       	push	r13
 41c:	ef 92       	push	r14
 41e:	ff 92       	push	r15
 420:	0f 93       	push	r16
 422:	1f 93       	push	r17
 424:	2f 93       	push	r18
 426:	3f 93       	push	r19
 428:	4f 93       	push	r20
 42a:	5f 93       	push	r21
 42c:	6f 93       	push	r22
 42e:	7f 93       	push	r23
 430:	8f 93       	push	r24
 432:	9f 93       	push	r25
 434:	af 93       	push	r26
 436:	bf 93       	push	r27
 438:	cf 93       	push	r28
 43a:	df 93       	push	r29
 43c:	ef 93       	push	r30
 43e:	ff 93       	push	r31
 440:	a0 91 2f 03 	lds	r26, 0x032F	; 0x80032f <pxCurrentTCB>
 444:	b0 91 30 03 	lds	r27, 0x0330	; 0x800330 <pxCurrentTCB+0x1>
 448:	0d b6       	in	r0, 0x3d	; 61
 44a:	0d 92       	st	X+, r0
 44c:	0e b6       	in	r0, 0x3e	; 62
 44e:	0d 92       	st	X+, r0
 450:	0e 94 a1 05 	call	0xb42	; 0xb42 <vTaskSwitchContext>
 454:	a0 91 2f 03 	lds	r26, 0x032F	; 0x80032f <pxCurrentTCB>
 458:	b0 91 30 03 	lds	r27, 0x0330	; 0x800330 <pxCurrentTCB+0x1>
 45c:	cd 91       	ld	r28, X+
 45e:	cd bf       	out	0x3d, r28	; 61
 460:	dd 91       	ld	r29, X+
 462:	de bf       	out	0x3e, r29	; 62
 464:	ff 91       	pop	r31
 466:	ef 91       	pop	r30
 468:	df 91       	pop	r29
 46a:	cf 91       	pop	r28
 46c:	bf 91       	pop	r27
 46e:	af 91       	pop	r26
 470:	9f 91       	pop	r25
 472:	8f 91       	pop	r24
 474:	7f 91       	pop	r23
 476:	6f 91       	pop	r22
 478:	5f 91       	pop	r21
 47a:	4f 91       	pop	r20
 47c:	3f 91       	pop	r19
 47e:	2f 91       	pop	r18
 480:	1f 91       	pop	r17
 482:	0f 91       	pop	r16
 484:	ff 90       	pop	r15
 486:	ef 90       	pop	r14
 488:	df 90       	pop	r13
 48a:	cf 90       	pop	r12
 48c:	bf 90       	pop	r11
 48e:	af 90       	pop	r10
 490:	9f 90       	pop	r9
 492:	8f 90       	pop	r8
 494:	7f 90       	pop	r7
 496:	6f 90       	pop	r6
 498:	5f 90       	pop	r5
 49a:	4f 90       	pop	r4
 49c:	3f 90       	pop	r3
 49e:	2f 90       	pop	r2
 4a0:	1f 90       	pop	r1
 4a2:	0f 90       	pop	r0
 4a4:	0f be       	out	0x3f, r0	; 63
 4a6:	0f 90       	pop	r0
 4a8:	08 95       	ret

000004aa <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal ) );
	void TIMER1_COMPA_vect( void )
	{
 4aa:	1f 92       	push	r1
 4ac:	0f 92       	push	r0
 4ae:	0f b6       	in	r0, 0x3f	; 63
 4b0:	0f 92       	push	r0
 4b2:	11 24       	eor	r1, r1
 4b4:	2f 93       	push	r18
 4b6:	3f 93       	push	r19
 4b8:	4f 93       	push	r20
 4ba:	5f 93       	push	r21
 4bc:	6f 93       	push	r22
 4be:	7f 93       	push	r23
 4c0:	8f 93       	push	r24
 4c2:	9f 93       	push	r25
 4c4:	af 93       	push	r26
 4c6:	bf 93       	push	r27
 4c8:	ef 93       	push	r30
 4ca:	ff 93       	push	r31
		vTaskIncrementTick();
 4cc:	0e 94 26 04 	call	0x84c	; 0x84c <vTaskIncrementTick>
	}
 4d0:	ff 91       	pop	r31
 4d2:	ef 91       	pop	r30
 4d4:	bf 91       	pop	r27
 4d6:	af 91       	pop	r26
 4d8:	9f 91       	pop	r25
 4da:	8f 91       	pop	r24
 4dc:	7f 91       	pop	r23
 4de:	6f 91       	pop	r22
 4e0:	5f 91       	pop	r21
 4e2:	4f 91       	pop	r20
 4e4:	3f 91       	pop	r19
 4e6:	2f 91       	pop	r18
 4e8:	0f 90       	pop	r0
 4ea:	0f be       	out	0x3f, r0	; 63
 4ec:	0f 90       	pop	r0
 4ee:	1f 90       	pop	r1
 4f0:	18 95       	reti

000004f2 <task1>:
for(;;)
	{
		for (int i =12 ; i>0 ; i--)
			{
			lcd_disp_string_xy("Hello" , 0 , i);
			lcd_disp_string_xy("World" , 1, 12-i);
 4f2:	0c e0       	ldi	r16, 0x0C	; 12
 4f4:	10 e0       	ldi	r17, 0x00	; 0

void task1 (void)
{
for(;;)
	{
		for (int i =12 ; i>0 ; i--)
 4f6:	cc e0       	ldi	r28, 0x0C	; 12
 4f8:	d0 e0       	ldi	r29, 0x00	; 0
			{
			lcd_disp_string_xy("Hello" , 0 , i);
 4fa:	ae 01       	movw	r20, r28
 4fc:	60 e0       	ldi	r22, 0x00	; 0
 4fe:	70 e0       	ldi	r23, 0x00	; 0
 500:	82 e6       	ldi	r24, 0x62	; 98
 502:	90 e0       	ldi	r25, 0x00	; 0
 504:	0e 94 ef 00 	call	0x1de	; 0x1de <lcd_disp_string_xy>
			lcd_disp_string_xy("World" , 1, 12-i);
 508:	a8 01       	movw	r20, r16
 50a:	4c 1b       	sub	r20, r28
 50c:	5d 0b       	sbc	r21, r29
 50e:	61 e0       	ldi	r22, 0x01	; 1
 510:	70 e0       	ldi	r23, 0x00	; 0
 512:	88 e6       	ldi	r24, 0x68	; 104
 514:	90 e0       	ldi	r25, 0x00	; 0
 516:	0e 94 ef 00 	call	0x1de	; 0x1de <lcd_disp_string_xy>
 51a:	2f ef       	ldi	r18, 0xFF	; 255
 51c:	80 e7       	ldi	r24, 0x70	; 112
 51e:	92 e0       	ldi	r25, 0x02	; 2
 520:	21 50       	subi	r18, 0x01	; 1
 522:	80 40       	sbci	r24, 0x00	; 0
 524:	90 40       	sbci	r25, 0x00	; 0
 526:	e1 f7       	brne	.-8      	; 0x520 <task1+0x2e>
 528:	00 c0       	rjmp	.+0      	; 0x52a <task1+0x38>
 52a:	00 00       	nop
			_delay_ms(100);
			lcd_clrScreen();
 52c:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <lcd_clrScreen>

void task1 (void)
{
for(;;)
	{
		for (int i =12 ; i>0 ; i--)
 530:	21 97       	sbiw	r28, 0x01	; 1
 532:	19 f7       	brne	.-58     	; 0x4fa <task1+0x8>
 534:	c0 e0       	ldi	r28, 0x00	; 0
 536:	d0 e0       	ldi	r29, 0x00	; 0
			_delay_ms(100);
			lcd_clrScreen();
			}
		for (int i =0 ; i<12 ; i++)
			{
			lcd_disp_string_xy("Hello" , 0 , i);
 538:	ae 01       	movw	r20, r28
 53a:	60 e0       	ldi	r22, 0x00	; 0
 53c:	70 e0       	ldi	r23, 0x00	; 0
 53e:	82 e6       	ldi	r24, 0x62	; 98
 540:	90 e0       	ldi	r25, 0x00	; 0
 542:	0e 94 ef 00 	call	0x1de	; 0x1de <lcd_disp_string_xy>
			lcd_disp_string_xy("World" , 1, 12-i);
 546:	a8 01       	movw	r20, r16
 548:	4c 1b       	sub	r20, r28
 54a:	5d 0b       	sbc	r21, r29
 54c:	61 e0       	ldi	r22, 0x01	; 1
 54e:	70 e0       	ldi	r23, 0x00	; 0
 550:	88 e6       	ldi	r24, 0x68	; 104
 552:	90 e0       	ldi	r25, 0x00	; 0
 554:	0e 94 ef 00 	call	0x1de	; 0x1de <lcd_disp_string_xy>
 558:	2f ef       	ldi	r18, 0xFF	; 255
 55a:	80 e7       	ldi	r24, 0x70	; 112
 55c:	92 e0       	ldi	r25, 0x02	; 2
 55e:	21 50       	subi	r18, 0x01	; 1
 560:	80 40       	sbci	r24, 0x00	; 0
 562:	90 40       	sbci	r25, 0x00	; 0
 564:	e1 f7       	brne	.-8      	; 0x55e <task1+0x6c>
 566:	00 c0       	rjmp	.+0      	; 0x568 <task1+0x76>
 568:	00 00       	nop
			_delay_ms(100);
			lcd_clrScreen();
 56a:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <lcd_clrScreen>
			lcd_disp_string_xy("Hello" , 0 , i);
			lcd_disp_string_xy("World" , 1, 12-i);
			_delay_ms(100);
			lcd_clrScreen();
			}
		for (int i =0 ; i<12 ; i++)
 56e:	21 96       	adiw	r28, 0x01	; 1
 570:	cc 30       	cpi	r28, 0x0C	; 12
 572:	d1 05       	cpc	r29, r1
 574:	09 f7       	brne	.-62     	; 0x538 <task1+0x46>
 576:	bf cf       	rjmp	.-130    	; 0x4f6 <task1+0x4>

00000578 <main>:
			lcd_clrScreen();
			}
	}
}
int main(void)
{	
 578:	af 92       	push	r10
 57a:	bf 92       	push	r11
 57c:	cf 92       	push	r12
 57e:	df 92       	push	r13
 580:	ef 92       	push	r14
 582:	ff 92       	push	r15
 584:	0f 93       	push	r16
 586:	cf 93       	push	r28
 588:	df 93       	push	r29
 58a:	00 d0       	rcall	.+0      	; 0x58c <main+0x14>
 58c:	cd b7       	in	r28, 0x3d	; 61
 58e:	de b7       	in	r29, 0x3e	; 62
xTaskHandle xHANDLE;
xTaskCreate(task1,NULL,50,NULL,1,&xHANDLE);
 590:	a1 2c       	mov	r10, r1
 592:	b1 2c       	mov	r11, r1
 594:	c1 2c       	mov	r12, r1
 596:	d1 2c       	mov	r13, r1
 598:	ce 01       	movw	r24, r28
 59a:	01 96       	adiw	r24, 0x01	; 1
 59c:	7c 01       	movw	r14, r24
 59e:	01 e0       	ldi	r16, 0x01	; 1
 5a0:	20 e0       	ldi	r18, 0x00	; 0
 5a2:	30 e0       	ldi	r19, 0x00	; 0
 5a4:	42 e3       	ldi	r20, 0x32	; 50
 5a6:	50 e0       	ldi	r21, 0x00	; 0
 5a8:	60 e0       	ldi	r22, 0x00	; 0
 5aa:	70 e0       	ldi	r23, 0x00	; 0
 5ac:	89 e7       	ldi	r24, 0x79	; 121
 5ae:	92 e0       	ldi	r25, 0x02	; 2
 5b0:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <xTaskGenericCreate>
lcd_init();
 5b4:	0e 94 99 00 	call	0x132	; 0x132 <lcd_init>
vTaskStartScheduler();
 5b8:	0e 94 f5 03 	call	0x7ea	; 0x7ea <vTaskStartScheduler>

	return 0;   
}
 5bc:	80 e0       	ldi	r24, 0x00	; 0
 5be:	90 e0       	ldi	r25, 0x00	; 0
 5c0:	0f 90       	pop	r0
 5c2:	0f 90       	pop	r0
 5c4:	df 91       	pop	r29
 5c6:	cf 91       	pop	r28
 5c8:	0f 91       	pop	r16
 5ca:	ff 90       	pop	r15
 5cc:	ef 90       	pop	r14
 5ce:	df 90       	pop	r13
 5d0:	cf 90       	pop	r12
 5d2:	bf 90       	pop	r11
 5d4:	af 90       	pop	r10
 5d6:	08 95       	ret

000005d8 <xTaskGenericCreate>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
 5d8:	4f 92       	push	r4
 5da:	5f 92       	push	r5
 5dc:	6f 92       	push	r6
 5de:	7f 92       	push	r7
 5e0:	8f 92       	push	r8
 5e2:	9f 92       	push	r9
 5e4:	af 92       	push	r10
 5e6:	bf 92       	push	r11
 5e8:	cf 92       	push	r12
 5ea:	df 92       	push	r13
 5ec:	ef 92       	push	r14
 5ee:	ff 92       	push	r15
 5f0:	0f 93       	push	r16
 5f2:	1f 93       	push	r17
 5f4:	cf 93       	push	r28
 5f6:	df 93       	push	r29
 5f8:	5c 01       	movw	r10, r24
 5fa:	4b 01       	movw	r8, r22
 5fc:	ea 01       	movw	r28, r20
 5fe:	29 01       	movw	r4, r18
 600:	81 e2       	ldi	r24, 0x21	; 33
 602:	90 e0       	ldi	r25, 0x00	; 0
 604:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
 608:	3c 01       	movw	r6, r24
 60a:	00 97       	sbiw	r24, 0x00	; 0
 60c:	09 f4       	brne	.+2      	; 0x610 <xTaskGenericCreate+0x38>
 60e:	db c0       	rjmp	.+438    	; 0x7c6 <xTaskGenericCreate+0x1ee>
 610:	c1 14       	cp	r12, r1
 612:	d1 04       	cpc	r13, r1
 614:	09 f0       	breq	.+2      	; 0x618 <xTaskGenericCreate+0x40>
 616:	d2 c0       	rjmp	.+420    	; 0x7bc <xTaskGenericCreate+0x1e4>
 618:	ce 01       	movw	r24, r28
 61a:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
 61e:	f3 01       	movw	r30, r6
 620:	90 8f       	std	Z+24, r25	; 0x18
 622:	87 8b       	std	Z+23, r24	; 0x17
 624:	00 97       	sbiw	r24, 0x00	; 0
 626:	21 f4       	brne	.+8      	; 0x630 <xTaskGenericCreate+0x58>
 628:	c3 01       	movw	r24, r6
 62a:	0e 94 6f 00 	call	0xde	; 0xde <vPortFree>
 62e:	cb c0       	rjmp	.+406    	; 0x7c6 <xTaskGenericCreate+0x1ee>
 630:	ae 01       	movw	r20, r28
 632:	65 ea       	ldi	r22, 0xA5	; 165
 634:	70 e0       	ldi	r23, 0x00	; 0
 636:	0e 94 0d 06 	call	0xc1a	; 0xc1a <memset>
 63a:	21 97       	sbiw	r28, 0x01	; 1
 63c:	f3 01       	movw	r30, r6
 63e:	87 89       	ldd	r24, Z+23	; 0x17
 640:	90 8d       	ldd	r25, Z+24	; 0x18
 642:	c8 0f       	add	r28, r24
 644:	d9 1f       	adc	r29, r25
 646:	48 e0       	ldi	r20, 0x08	; 8
 648:	50 e0       	ldi	r21, 0x00	; 0
 64a:	b4 01       	movw	r22, r8
 64c:	c3 01       	movw	r24, r6
 64e:	49 96       	adiw	r24, 0x19	; 25
 650:	0e 94 14 06 	call	0xc28	; 0xc28 <strncpy>
 654:	f3 01       	movw	r30, r6
 656:	10 a2       	std	Z+32, r1	; 0x20
 658:	10 2f       	mov	r17, r16
 65a:	05 30       	cpi	r16, 0x05	; 5
 65c:	08 f0       	brcs	.+2      	; 0x660 <xTaskGenericCreate+0x88>
 65e:	14 e0       	ldi	r17, 0x04	; 4
 660:	f3 01       	movw	r30, r6
 662:	16 8b       	std	Z+22, r17	; 0x16
 664:	63 01       	movw	r12, r6
 666:	f2 e0       	ldi	r31, 0x02	; 2
 668:	cf 0e       	add	r12, r31
 66a:	d1 1c       	adc	r13, r1
 66c:	c6 01       	movw	r24, r12
 66e:	0e 94 0a 01 	call	0x214	; 0x214 <vListInitialiseItem>
 672:	c3 01       	movw	r24, r6
 674:	0c 96       	adiw	r24, 0x0c	; 12
 676:	0e 94 0a 01 	call	0x214	; 0x214 <vListInitialiseItem>
 67a:	f3 01       	movw	r30, r6
 67c:	71 86       	std	Z+9, r7	; 0x09
 67e:	60 86       	std	Z+8, r6	; 0x08
 680:	85 e0       	ldi	r24, 0x05	; 5
 682:	90 e0       	ldi	r25, 0x00	; 0
 684:	81 1b       	sub	r24, r17
 686:	91 09       	sbc	r25, r1
 688:	95 87       	std	Z+13, r25	; 0x0d
 68a:	84 87       	std	Z+12, r24	; 0x0c
 68c:	73 8a       	std	Z+19, r7	; 0x13
 68e:	62 8a       	std	Z+18, r6	; 0x12
 690:	a2 01       	movw	r20, r4
 692:	b5 01       	movw	r22, r10
 694:	ce 01       	movw	r24, r28
 696:	0e 94 5b 01 	call	0x2b6	; 0x2b6 <pxPortInitialiseStack>
 69a:	f3 01       	movw	r30, r6
 69c:	91 83       	std	Z+1, r25	; 0x01
 69e:	80 83       	st	Z, r24
 6a0:	e1 14       	cp	r14, r1
 6a2:	f1 04       	cpc	r15, r1
 6a4:	19 f0       	breq	.+6      	; 0x6ac <xTaskGenericCreate+0xd4>
 6a6:	f7 01       	movw	r30, r14
 6a8:	71 82       	std	Z+1, r7	; 0x01
 6aa:	60 82       	st	Z, r6
 6ac:	0f b6       	in	r0, 0x3f	; 63
 6ae:	f8 94       	cli
 6b0:	0f 92       	push	r0
 6b2:	80 91 d8 02 	lds	r24, 0x02D8	; 0x8002d8 <uxCurrentNumberOfTasks>
 6b6:	8f 5f       	subi	r24, 0xFF	; 255
 6b8:	80 93 d8 02 	sts	0x02D8, r24	; 0x8002d8 <uxCurrentNumberOfTasks>
 6bc:	80 91 2f 03 	lds	r24, 0x032F	; 0x80032f <pxCurrentTCB>
 6c0:	90 91 30 03 	lds	r25, 0x0330	; 0x800330 <pxCurrentTCB+0x1>
 6c4:	89 2b       	or	r24, r25
 6c6:	a1 f5       	brne	.+104    	; 0x730 <xTaskGenericCreate+0x158>
 6c8:	70 92 30 03 	sts	0x0330, r7	; 0x800330 <pxCurrentTCB+0x1>
 6cc:	60 92 2f 03 	sts	0x032F, r6	; 0x80032f <pxCurrentTCB>
 6d0:	80 91 d8 02 	lds	r24, 0x02D8	; 0x8002d8 <uxCurrentNumberOfTasks>
 6d4:	81 30       	cpi	r24, 0x01	; 1
 6d6:	d9 f5       	brne	.+118    	; 0x74e <xTaskGenericCreate+0x176>
 6d8:	c2 e0       	ldi	r28, 0x02	; 2
 6da:	d3 e0       	ldi	r29, 0x03	; 3
 6dc:	0f 2e       	mov	r0, r31
 6de:	ff e2       	ldi	r31, 0x2F	; 47
 6e0:	ef 2e       	mov	r14, r31
 6e2:	f3 e0       	ldi	r31, 0x03	; 3
 6e4:	ff 2e       	mov	r15, r31
 6e6:	f0 2d       	mov	r31, r0
 6e8:	ce 01       	movw	r24, r28
 6ea:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <vListInitialise>
 6ee:	29 96       	adiw	r28, 0x09	; 9
 6f0:	ce 15       	cp	r28, r14
 6f2:	df 05       	cpc	r29, r15
 6f4:	c9 f7       	brne	.-14     	; 0x6e8 <xTaskGenericCreate+0x110>
 6f6:	89 ef       	ldi	r24, 0xF9	; 249
 6f8:	92 e0       	ldi	r25, 0x02	; 2
 6fa:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <vListInitialise>
 6fe:	80 ef       	ldi	r24, 0xF0	; 240
 700:	92 e0       	ldi	r25, 0x02	; 2
 702:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <vListInitialise>
 706:	83 ee       	ldi	r24, 0xE3	; 227
 708:	92 e0       	ldi	r25, 0x02	; 2
 70a:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <vListInitialise>
 70e:	8a ed       	ldi	r24, 0xDA	; 218
 710:	92 e0       	ldi	r25, 0x02	; 2
 712:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <vListInitialise>
 716:	89 ef       	ldi	r24, 0xF9	; 249
 718:	92 e0       	ldi	r25, 0x02	; 2
 71a:	90 93 ef 02 	sts	0x02EF, r25	; 0x8002ef <pxDelayedTaskList+0x1>
 71e:	80 93 ee 02 	sts	0x02EE, r24	; 0x8002ee <pxDelayedTaskList>
 722:	80 ef       	ldi	r24, 0xF0	; 240
 724:	92 e0       	ldi	r25, 0x02	; 2
 726:	90 93 ed 02 	sts	0x02ED, r25	; 0x8002ed <pxOverflowDelayedTaskList+0x1>
 72a:	80 93 ec 02 	sts	0x02EC, r24	; 0x8002ec <pxOverflowDelayedTaskList>
 72e:	0f c0       	rjmp	.+30     	; 0x74e <xTaskGenericCreate+0x176>
 730:	80 91 d3 02 	lds	r24, 0x02D3	; 0x8002d3 <xSchedulerRunning>
 734:	81 11       	cpse	r24, r1
 736:	0b c0       	rjmp	.+22     	; 0x74e <xTaskGenericCreate+0x176>
 738:	e0 91 2f 03 	lds	r30, 0x032F	; 0x80032f <pxCurrentTCB>
 73c:	f0 91 30 03 	lds	r31, 0x0330	; 0x800330 <pxCurrentTCB+0x1>
 740:	86 89       	ldd	r24, Z+22	; 0x16
 742:	08 17       	cp	r16, r24
 744:	20 f0       	brcs	.+8      	; 0x74e <xTaskGenericCreate+0x176>
 746:	70 92 30 03 	sts	0x0330, r7	; 0x800330 <pxCurrentTCB+0x1>
 74a:	60 92 2f 03 	sts	0x032F, r6	; 0x80032f <pxCurrentTCB>
 74e:	f3 01       	movw	r30, r6
 750:	86 89       	ldd	r24, Z+22	; 0x16
 752:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <uxTopUsedPriority>
 756:	98 17       	cp	r25, r24
 758:	10 f4       	brcc	.+4      	; 0x75e <xTaskGenericCreate+0x186>
 75a:	80 93 d5 02 	sts	0x02D5, r24	; 0x8002d5 <uxTopUsedPriority>
 75e:	90 91 ce 02 	lds	r25, 0x02CE	; 0x8002ce <uxTaskNumber>
 762:	9f 5f       	subi	r25, 0xFF	; 255
 764:	90 93 ce 02 	sts	0x02CE, r25	; 0x8002ce <uxTaskNumber>
 768:	90 91 d4 02 	lds	r25, 0x02D4	; 0x8002d4 <uxTopReadyPriority>
 76c:	98 17       	cp	r25, r24
 76e:	10 f4       	brcc	.+4      	; 0x774 <xTaskGenericCreate+0x19c>
 770:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <uxTopReadyPriority>
 774:	90 e0       	ldi	r25, 0x00	; 0
 776:	9c 01       	movw	r18, r24
 778:	22 0f       	add	r18, r18
 77a:	33 1f       	adc	r19, r19
 77c:	22 0f       	add	r18, r18
 77e:	33 1f       	adc	r19, r19
 780:	22 0f       	add	r18, r18
 782:	33 1f       	adc	r19, r19
 784:	82 0f       	add	r24, r18
 786:	93 1f       	adc	r25, r19
 788:	b6 01       	movw	r22, r12
 78a:	8e 5f       	subi	r24, 0xFE	; 254
 78c:	9c 4f       	sbci	r25, 0xFC	; 252
 78e:	0e 94 0e 01 	call	0x21c	; 0x21c <vListInsertEnd>
 792:	0f 90       	pop	r0
 794:	0f be       	out	0x3f, r0	; 63
 796:	80 91 d3 02 	lds	r24, 0x02D3	; 0x8002d3 <xSchedulerRunning>
 79a:	88 23       	and	r24, r24
 79c:	59 f0       	breq	.+22     	; 0x7b4 <xTaskGenericCreate+0x1dc>
 79e:	e0 91 2f 03 	lds	r30, 0x032F	; 0x80032f <pxCurrentTCB>
 7a2:	f0 91 30 03 	lds	r31, 0x0330	; 0x800330 <pxCurrentTCB+0x1>
 7a6:	86 89       	ldd	r24, Z+22	; 0x16
 7a8:	80 17       	cp	r24, r16
 7aa:	30 f4       	brcc	.+12     	; 0x7b8 <xTaskGenericCreate+0x1e0>
 7ac:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <vPortYield>
 7b0:	81 e0       	ldi	r24, 0x01	; 1
 7b2:	0a c0       	rjmp	.+20     	; 0x7c8 <xTaskGenericCreate+0x1f0>
 7b4:	81 e0       	ldi	r24, 0x01	; 1
 7b6:	08 c0       	rjmp	.+16     	; 0x7c8 <xTaskGenericCreate+0x1f0>
 7b8:	81 e0       	ldi	r24, 0x01	; 1
 7ba:	06 c0       	rjmp	.+12     	; 0x7c8 <xTaskGenericCreate+0x1f0>
 7bc:	fc 01       	movw	r30, r24
 7be:	d0 8e       	std	Z+24, r13	; 0x18
 7c0:	c7 8a       	std	Z+23, r12	; 0x17
 7c2:	c6 01       	movw	r24, r12
 7c4:	35 cf       	rjmp	.-406    	; 0x630 <xTaskGenericCreate+0x58>
 7c6:	8f ef       	ldi	r24, 0xFF	; 255
 7c8:	df 91       	pop	r29
 7ca:	cf 91       	pop	r28
 7cc:	1f 91       	pop	r17
 7ce:	0f 91       	pop	r16
 7d0:	ff 90       	pop	r15
 7d2:	ef 90       	pop	r14
 7d4:	df 90       	pop	r13
 7d6:	cf 90       	pop	r12
 7d8:	bf 90       	pop	r11
 7da:	af 90       	pop	r10
 7dc:	9f 90       	pop	r9
 7de:	8f 90       	pop	r8
 7e0:	7f 90       	pop	r7
 7e2:	6f 90       	pop	r6
 7e4:	5f 90       	pop	r5
 7e6:	4f 90       	pop	r4
 7e8:	08 95       	ret

000007ea <vTaskStartScheduler>:
 7ea:	af 92       	push	r10
 7ec:	bf 92       	push	r11
 7ee:	cf 92       	push	r12
 7f0:	df 92       	push	r13
 7f2:	ef 92       	push	r14
 7f4:	ff 92       	push	r15
 7f6:	0f 93       	push	r16
 7f8:	a1 2c       	mov	r10, r1
 7fa:	b1 2c       	mov	r11, r1
 7fc:	c1 2c       	mov	r12, r1
 7fe:	d1 2c       	mov	r13, r1
 800:	e1 2c       	mov	r14, r1
 802:	f1 2c       	mov	r15, r1
 804:	00 e0       	ldi	r16, 0x00	; 0
 806:	20 e0       	ldi	r18, 0x00	; 0
 808:	30 e0       	ldi	r19, 0x00	; 0
 80a:	45 e5       	ldi	r20, 0x55	; 85
 80c:	50 e0       	ldi	r21, 0x00	; 0
 80e:	6e e6       	ldi	r22, 0x6E	; 110
 810:	70 e0       	ldi	r23, 0x00	; 0
 812:	8f e6       	ldi	r24, 0x6F	; 111
 814:	95 e0       	ldi	r25, 0x05	; 5
 816:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <xTaskGenericCreate>
 81a:	81 30       	cpi	r24, 0x01	; 1
 81c:	49 f4       	brne	.+18     	; 0x830 <vTaskStartScheduler+0x46>
 81e:	f8 94       	cli
 820:	80 93 d3 02 	sts	0x02D3, r24	; 0x8002d3 <xSchedulerRunning>
 824:	10 92 d7 02 	sts	0x02D7, r1	; 0x8002d7 <xTickCount+0x1>
 828:	10 92 d6 02 	sts	0x02D6, r1	; 0x8002d6 <xTickCount>
 82c:	0e 94 c7 01 	call	0x38e	; 0x38e <xPortStartScheduler>
 830:	0f 91       	pop	r16
 832:	ff 90       	pop	r15
 834:	ef 90       	pop	r14
 836:	df 90       	pop	r13
 838:	cf 90       	pop	r12
 83a:	bf 90       	pop	r11
 83c:	af 90       	pop	r10
 83e:	08 95       	ret

00000840 <vTaskSuspendAll>:
 840:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <uxSchedulerSuspended>
 844:	8f 5f       	subi	r24, 0xFF	; 255
 846:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <uxSchedulerSuspended>
 84a:	08 95       	ret

0000084c <vTaskIncrementTick>:
 84c:	0f 93       	push	r16
 84e:	1f 93       	push	r17
 850:	cf 93       	push	r28
 852:	df 93       	push	r29
 854:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <uxSchedulerSuspended>
 858:	81 11       	cpse	r24, r1
 85a:	b2 c0       	rjmp	.+356    	; 0x9c0 <__stack+0x161>
 85c:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <xTickCount>
 860:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <xTickCount+0x1>
 864:	01 96       	adiw	r24, 0x01	; 1
 866:	90 93 d7 02 	sts	0x02D7, r25	; 0x8002d7 <xTickCount+0x1>
 86a:	80 93 d6 02 	sts	0x02D6, r24	; 0x8002d6 <xTickCount>
 86e:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <xTickCount>
 872:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <xTickCount+0x1>
 876:	89 2b       	or	r24, r25
 878:	99 f5       	brne	.+102    	; 0x8e0 <__stack+0x81>
 87a:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <pxDelayedTaskList>
 87e:	90 91 ef 02 	lds	r25, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
 882:	20 91 ec 02 	lds	r18, 0x02EC	; 0x8002ec <pxOverflowDelayedTaskList>
 886:	30 91 ed 02 	lds	r19, 0x02ED	; 0x8002ed <pxOverflowDelayedTaskList+0x1>
 88a:	30 93 ef 02 	sts	0x02EF, r19	; 0x8002ef <pxDelayedTaskList+0x1>
 88e:	20 93 ee 02 	sts	0x02EE, r18	; 0x8002ee <pxDelayedTaskList>
 892:	90 93 ed 02 	sts	0x02ED, r25	; 0x8002ed <pxOverflowDelayedTaskList+0x1>
 896:	80 93 ec 02 	sts	0x02EC, r24	; 0x8002ec <pxOverflowDelayedTaskList>
 89a:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <xNumOfOverflows>
 89e:	8f 5f       	subi	r24, 0xFF	; 255
 8a0:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <xNumOfOverflows>
 8a4:	e0 91 ee 02 	lds	r30, 0x02EE	; 0x8002ee <pxDelayedTaskList>
 8a8:	f0 91 ef 02 	lds	r31, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
 8ac:	80 81       	ld	r24, Z
 8ae:	81 11       	cpse	r24, r1
 8b0:	07 c0       	rjmp	.+14     	; 0x8c0 <__stack+0x61>
 8b2:	8f ef       	ldi	r24, 0xFF	; 255
 8b4:	9f ef       	ldi	r25, 0xFF	; 255
 8b6:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
 8ba:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 8be:	10 c0       	rjmp	.+32     	; 0x8e0 <__stack+0x81>
 8c0:	e0 91 ee 02 	lds	r30, 0x02EE	; 0x8002ee <pxDelayedTaskList>
 8c4:	f0 91 ef 02 	lds	r31, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
 8c8:	05 80       	ldd	r0, Z+5	; 0x05
 8ca:	f6 81       	ldd	r31, Z+6	; 0x06
 8cc:	e0 2d       	mov	r30, r0
 8ce:	06 80       	ldd	r0, Z+6	; 0x06
 8d0:	f7 81       	ldd	r31, Z+7	; 0x07
 8d2:	e0 2d       	mov	r30, r0
 8d4:	82 81       	ldd	r24, Z+2	; 0x02
 8d6:	93 81       	ldd	r25, Z+3	; 0x03
 8d8:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
 8dc:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 8e0:	20 91 d6 02 	lds	r18, 0x02D6	; 0x8002d6 <xTickCount>
 8e4:	30 91 d7 02 	lds	r19, 0x02D7	; 0x8002d7 <xTickCount+0x1>
 8e8:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
 8ec:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
 8f0:	28 17       	cp	r18, r24
 8f2:	39 07       	cpc	r19, r25
 8f4:	08 f4       	brcc	.+2      	; 0x8f8 <__stack+0x99>
 8f6:	69 c0       	rjmp	.+210    	; 0x9ca <__stack+0x16b>
 8f8:	e0 91 ee 02 	lds	r30, 0x02EE	; 0x8002ee <pxDelayedTaskList>
 8fc:	f0 91 ef 02 	lds	r31, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
 900:	80 81       	ld	r24, Z
 902:	88 23       	and	r24, r24
 904:	99 f0       	breq	.+38     	; 0x92c <__stack+0xcd>
 906:	e0 91 ee 02 	lds	r30, 0x02EE	; 0x8002ee <pxDelayedTaskList>
 90a:	f0 91 ef 02 	lds	r31, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
 90e:	05 80       	ldd	r0, Z+5	; 0x05
 910:	f6 81       	ldd	r31, Z+6	; 0x06
 912:	e0 2d       	mov	r30, r0
 914:	c6 81       	ldd	r28, Z+6	; 0x06
 916:	d7 81       	ldd	r29, Z+7	; 0x07
 918:	8a 81       	ldd	r24, Y+2	; 0x02
 91a:	9b 81       	ldd	r25, Y+3	; 0x03
 91c:	20 91 d6 02 	lds	r18, 0x02D6	; 0x8002d6 <xTickCount>
 920:	30 91 d7 02 	lds	r19, 0x02D7	; 0x8002d7 <xTickCount+0x1>
 924:	28 17       	cp	r18, r24
 926:	39 07       	cpc	r19, r25
 928:	f8 f4       	brcc	.+62     	; 0x968 <__stack+0x109>
 92a:	19 c0       	rjmp	.+50     	; 0x95e <__stack+0xff>
 92c:	8f ef       	ldi	r24, 0xFF	; 255
 92e:	9f ef       	ldi	r25, 0xFF	; 255
 930:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
 934:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 938:	48 c0       	rjmp	.+144    	; 0x9ca <__stack+0x16b>
 93a:	e0 91 ee 02 	lds	r30, 0x02EE	; 0x8002ee <pxDelayedTaskList>
 93e:	f0 91 ef 02 	lds	r31, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
 942:	05 80       	ldd	r0, Z+5	; 0x05
 944:	f6 81       	ldd	r31, Z+6	; 0x06
 946:	e0 2d       	mov	r30, r0
 948:	c6 81       	ldd	r28, Z+6	; 0x06
 94a:	d7 81       	ldd	r29, Z+7	; 0x07
 94c:	8a 81       	ldd	r24, Y+2	; 0x02
 94e:	9b 81       	ldd	r25, Y+3	; 0x03
 950:	20 91 d6 02 	lds	r18, 0x02D6	; 0x8002d6 <xTickCount>
 954:	30 91 d7 02 	lds	r19, 0x02D7	; 0x8002d7 <xTickCount+0x1>
 958:	28 17       	cp	r18, r24
 95a:	39 07       	cpc	r19, r25
 95c:	28 f4       	brcc	.+10     	; 0x968 <__stack+0x109>
 95e:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
 962:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 966:	31 c0       	rjmp	.+98     	; 0x9ca <__stack+0x16b>
 968:	8e 01       	movw	r16, r28
 96a:	0e 5f       	subi	r16, 0xFE	; 254
 96c:	1f 4f       	sbci	r17, 0xFF	; 255
 96e:	c8 01       	movw	r24, r16
 970:	0e 94 35 01 	call	0x26a	; 0x26a <vListRemove>
 974:	8c 89       	ldd	r24, Y+20	; 0x14
 976:	9d 89       	ldd	r25, Y+21	; 0x15
 978:	89 2b       	or	r24, r25
 97a:	21 f0       	breq	.+8      	; 0x984 <__stack+0x125>
 97c:	ce 01       	movw	r24, r28
 97e:	0c 96       	adiw	r24, 0x0c	; 12
 980:	0e 94 35 01 	call	0x26a	; 0x26a <vListRemove>
 984:	8e 89       	ldd	r24, Y+22	; 0x16
 986:	90 91 d4 02 	lds	r25, 0x02D4	; 0x8002d4 <uxTopReadyPriority>
 98a:	98 17       	cp	r25, r24
 98c:	10 f4       	brcc	.+4      	; 0x992 <__stack+0x133>
 98e:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <uxTopReadyPriority>
 992:	90 e0       	ldi	r25, 0x00	; 0
 994:	9c 01       	movw	r18, r24
 996:	22 0f       	add	r18, r18
 998:	33 1f       	adc	r19, r19
 99a:	22 0f       	add	r18, r18
 99c:	33 1f       	adc	r19, r19
 99e:	22 0f       	add	r18, r18
 9a0:	33 1f       	adc	r19, r19
 9a2:	82 0f       	add	r24, r18
 9a4:	93 1f       	adc	r25, r19
 9a6:	b8 01       	movw	r22, r16
 9a8:	8e 5f       	subi	r24, 0xFE	; 254
 9aa:	9c 4f       	sbci	r25, 0xFC	; 252
 9ac:	0e 94 0e 01 	call	0x21c	; 0x21c <vListInsertEnd>
 9b0:	e0 91 ee 02 	lds	r30, 0x02EE	; 0x8002ee <pxDelayedTaskList>
 9b4:	f0 91 ef 02 	lds	r31, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
 9b8:	80 81       	ld	r24, Z
 9ba:	81 11       	cpse	r24, r1
 9bc:	be cf       	rjmp	.-132    	; 0x93a <__stack+0xdb>
 9be:	b6 cf       	rjmp	.-148    	; 0x92c <__stack+0xcd>
 9c0:	80 91 d1 02 	lds	r24, 0x02D1	; 0x8002d1 <uxMissedTicks>
 9c4:	8f 5f       	subi	r24, 0xFF	; 255
 9c6:	80 93 d1 02 	sts	0x02D1, r24	; 0x8002d1 <uxMissedTicks>
 9ca:	df 91       	pop	r29
 9cc:	cf 91       	pop	r28
 9ce:	1f 91       	pop	r17
 9d0:	0f 91       	pop	r16
 9d2:	08 95       	ret

000009d4 <xTaskResumeAll>:
 9d4:	cf 92       	push	r12
 9d6:	df 92       	push	r13
 9d8:	ef 92       	push	r14
 9da:	ff 92       	push	r15
 9dc:	0f 93       	push	r16
 9de:	1f 93       	push	r17
 9e0:	cf 93       	push	r28
 9e2:	df 93       	push	r29
 9e4:	0f b6       	in	r0, 0x3f	; 63
 9e6:	f8 94       	cli
 9e8:	0f 92       	push	r0
 9ea:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <uxSchedulerSuspended>
 9ee:	81 50       	subi	r24, 0x01	; 1
 9f0:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <uxSchedulerSuspended>
 9f4:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <uxSchedulerSuspended>
 9f8:	81 11       	cpse	r24, r1
 9fa:	63 c0       	rjmp	.+198    	; 0xac2 <xTaskResumeAll+0xee>
 9fc:	80 91 d8 02 	lds	r24, 0x02D8	; 0x8002d8 <uxCurrentNumberOfTasks>
 a00:	81 11       	cpse	r24, r1
 a02:	32 c0       	rjmp	.+100    	; 0xa68 <xTaskResumeAll+0x94>
 a04:	61 c0       	rjmp	.+194    	; 0xac8 <xTaskResumeAll+0xf4>
 a06:	d7 01       	movw	r26, r14
 a08:	15 96       	adiw	r26, 0x05	; 5
 a0a:	ed 91       	ld	r30, X+
 a0c:	fc 91       	ld	r31, X
 a0e:	16 97       	sbiw	r26, 0x06	; 6
 a10:	c6 81       	ldd	r28, Z+6	; 0x06
 a12:	d7 81       	ldd	r29, Z+7	; 0x07
 a14:	ce 01       	movw	r24, r28
 a16:	0c 96       	adiw	r24, 0x0c	; 12
 a18:	0e 94 35 01 	call	0x26a	; 0x26a <vListRemove>
 a1c:	8e 01       	movw	r16, r28
 a1e:	0e 5f       	subi	r16, 0xFE	; 254
 a20:	1f 4f       	sbci	r17, 0xFF	; 255
 a22:	c8 01       	movw	r24, r16
 a24:	0e 94 35 01 	call	0x26a	; 0x26a <vListRemove>
 a28:	8e 89       	ldd	r24, Y+22	; 0x16
 a2a:	90 91 d4 02 	lds	r25, 0x02D4	; 0x8002d4 <uxTopReadyPriority>
 a2e:	98 17       	cp	r25, r24
 a30:	10 f4       	brcc	.+4      	; 0xa36 <xTaskResumeAll+0x62>
 a32:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <uxTopReadyPriority>
 a36:	90 e0       	ldi	r25, 0x00	; 0
 a38:	9c 01       	movw	r18, r24
 a3a:	22 0f       	add	r18, r18
 a3c:	33 1f       	adc	r19, r19
 a3e:	22 0f       	add	r18, r18
 a40:	33 1f       	adc	r19, r19
 a42:	22 0f       	add	r18, r18
 a44:	33 1f       	adc	r19, r19
 a46:	82 0f       	add	r24, r18
 a48:	93 1f       	adc	r25, r19
 a4a:	b8 01       	movw	r22, r16
 a4c:	8e 5f       	subi	r24, 0xFE	; 254
 a4e:	9c 4f       	sbci	r25, 0xFC	; 252
 a50:	0e 94 0e 01 	call	0x21c	; 0x21c <vListInsertEnd>
 a54:	e0 91 2f 03 	lds	r30, 0x032F	; 0x80032f <pxCurrentTCB>
 a58:	f0 91 30 03 	lds	r31, 0x0330	; 0x800330 <pxCurrentTCB+0x1>
 a5c:	9e 89       	ldd	r25, Y+22	; 0x16
 a5e:	86 89       	ldd	r24, Z+22	; 0x16
 a60:	98 17       	cp	r25, r24
 a62:	58 f0       	brcs	.+22     	; 0xa7a <xTaskResumeAll+0xa6>
 a64:	dc 2c       	mov	r13, r12
 a66:	09 c0       	rjmp	.+18     	; 0xa7a <xTaskResumeAll+0xa6>
 a68:	d1 2c       	mov	r13, r1
 a6a:	0f 2e       	mov	r0, r31
 a6c:	f3 ee       	ldi	r31, 0xE3	; 227
 a6e:	ef 2e       	mov	r14, r31
 a70:	f2 e0       	ldi	r31, 0x02	; 2
 a72:	ff 2e       	mov	r15, r31
 a74:	f0 2d       	mov	r31, r0
 a76:	cc 24       	eor	r12, r12
 a78:	c3 94       	inc	r12
 a7a:	f7 01       	movw	r30, r14
 a7c:	80 81       	ld	r24, Z
 a7e:	81 11       	cpse	r24, r1
 a80:	c2 cf       	rjmp	.-124    	; 0xa06 <xTaskResumeAll+0x32>
 a82:	80 91 d1 02 	lds	r24, 0x02D1	; 0x8002d1 <uxMissedTicks>
 a86:	88 23       	and	r24, r24
 a88:	79 f0       	breq	.+30     	; 0xaa8 <xTaskResumeAll+0xd4>
 a8a:	80 91 d1 02 	lds	r24, 0x02D1	; 0x8002d1 <uxMissedTicks>
 a8e:	88 23       	and	r24, r24
 a90:	59 f0       	breq	.+22     	; 0xaa8 <xTaskResumeAll+0xd4>
 a92:	0e 94 26 04 	call	0x84c	; 0x84c <vTaskIncrementTick>
 a96:	80 91 d1 02 	lds	r24, 0x02D1	; 0x8002d1 <uxMissedTicks>
 a9a:	81 50       	subi	r24, 0x01	; 1
 a9c:	80 93 d1 02 	sts	0x02D1, r24	; 0x8002d1 <uxMissedTicks>
 aa0:	80 91 d1 02 	lds	r24, 0x02D1	; 0x8002d1 <uxMissedTicks>
 aa4:	81 11       	cpse	r24, r1
 aa6:	f5 cf       	rjmp	.-22     	; 0xa92 <xTaskResumeAll+0xbe>
 aa8:	f1 e0       	ldi	r31, 0x01	; 1
 aaa:	df 16       	cp	r13, r31
 aac:	21 f0       	breq	.+8      	; 0xab6 <xTaskResumeAll+0xe2>
 aae:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <xMissedYield>
 ab2:	81 30       	cpi	r24, 0x01	; 1
 ab4:	41 f4       	brne	.+16     	; 0xac6 <xTaskResumeAll+0xf2>
 ab6:	10 92 d0 02 	sts	0x02D0, r1	; 0x8002d0 <xMissedYield>
 aba:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <vPortYield>
 abe:	81 e0       	ldi	r24, 0x01	; 1
 ac0:	03 c0       	rjmp	.+6      	; 0xac8 <xTaskResumeAll+0xf4>
 ac2:	80 e0       	ldi	r24, 0x00	; 0
 ac4:	01 c0       	rjmp	.+2      	; 0xac8 <xTaskResumeAll+0xf4>
 ac6:	80 e0       	ldi	r24, 0x00	; 0
 ac8:	0f 90       	pop	r0
 aca:	0f be       	out	0x3f, r0	; 63
 acc:	df 91       	pop	r29
 ace:	cf 91       	pop	r28
 ad0:	1f 91       	pop	r17
 ad2:	0f 91       	pop	r16
 ad4:	ff 90       	pop	r15
 ad6:	ef 90       	pop	r14
 ad8:	df 90       	pop	r13
 ada:	cf 90       	pop	r12
 adc:	08 95       	ret

00000ade <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 ade:	0a ed       	ldi	r16, 0xDA	; 218
 ae0:	12 e0       	ldi	r17, 0x02	; 2
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 ae2:	80 91 d9 02 	lds	r24, 0x02D9	; 0x8002d9 <uxTasksDeleted>
 ae6:	88 23       	and	r24, r24
 ae8:	49 f1       	breq	.+82     	; 0xb3c <prvIdleTask+0x5e>
		{
			vTaskSuspendAll();
 aea:	0e 94 20 04 	call	0x840	; 0x840 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 aee:	d8 01       	movw	r26, r16
 af0:	cc 91       	ld	r28, X
			xTaskResumeAll();
 af2:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 af6:	cc 23       	and	r28, r28
 af8:	09 f1       	breq	.+66     	; 0xb3c <prvIdleTask+0x5e>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 afa:	0f b6       	in	r0, 0x3f	; 63
 afc:	f8 94       	cli
 afe:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 b00:	d8 01       	movw	r26, r16
 b02:	15 96       	adiw	r26, 0x05	; 5
 b04:	ed 91       	ld	r30, X+
 b06:	fc 91       	ld	r31, X
 b08:	16 97       	sbiw	r26, 0x06	; 6
 b0a:	c6 81       	ldd	r28, Z+6	; 0x06
 b0c:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
 b0e:	ce 01       	movw	r24, r28
 b10:	02 96       	adiw	r24, 0x02	; 2
 b12:	0e 94 35 01 	call	0x26a	; 0x26a <vListRemove>
					--uxCurrentNumberOfTasks;
 b16:	80 91 d8 02 	lds	r24, 0x02D8	; 0x8002d8 <uxCurrentNumberOfTasks>
 b1a:	81 50       	subi	r24, 0x01	; 1
 b1c:	80 93 d8 02 	sts	0x02D8, r24	; 0x8002d8 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
 b20:	80 91 d9 02 	lds	r24, 0x02D9	; 0x8002d9 <uxTasksDeleted>
 b24:	81 50       	subi	r24, 0x01	; 1
 b26:	80 93 d9 02 	sts	0x02D9, r24	; 0x8002d9 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
 b2a:	0f 90       	pop	r0
 b2c:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 b2e:	8f 89       	ldd	r24, Y+23	; 0x17
 b30:	98 8d       	ldd	r25, Y+24	; 0x18
 b32:	0e 94 6f 00 	call	0xde	; 0xde <vPortFree>
		vPortFree( pxTCB );
 b36:	ce 01       	movw	r24, r28
 b38:	0e 94 6f 00 	call	0xde	; 0xde <vPortFree>
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
 b3c:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <vPortYield>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
 b40:	d0 cf       	rjmp	.-96     	; 0xae2 <prvIdleTask+0x4>

00000b42 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 b42:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <uxSchedulerSuspended>
 b46:	81 11       	cpse	r24, r1
 b48:	13 c0       	rjmp	.+38     	; 0xb70 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 b4a:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <uxTopReadyPriority>
 b4e:	90 e0       	ldi	r25, 0x00	; 0
 b50:	fc 01       	movw	r30, r24
 b52:	ee 0f       	add	r30, r30
 b54:	ff 1f       	adc	r31, r31
 b56:	ee 0f       	add	r30, r30
 b58:	ff 1f       	adc	r31, r31
 b5a:	ee 0f       	add	r30, r30
 b5c:	ff 1f       	adc	r31, r31
 b5e:	8e 0f       	add	r24, r30
 b60:	9f 1f       	adc	r25, r31
 b62:	fc 01       	movw	r30, r24
 b64:	ee 5f       	subi	r30, 0xFE	; 254
 b66:	fc 4f       	sbci	r31, 0xFC	; 252
 b68:	80 81       	ld	r24, Z
 b6a:	88 23       	and	r24, r24
 b6c:	29 f0       	breq	.+10     	; 0xb78 <vTaskSwitchContext+0x36>
 b6e:	1b c0       	rjmp	.+54     	; 0xba6 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 b70:	81 e0       	ldi	r24, 0x01	; 1
 b72:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <xMissedYield>
 b76:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
 b78:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <uxTopReadyPriority>
 b7c:	81 50       	subi	r24, 0x01	; 1
 b7e:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 b82:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <uxTopReadyPriority>
 b86:	90 e0       	ldi	r25, 0x00	; 0
 b88:	fc 01       	movw	r30, r24
 b8a:	ee 0f       	add	r30, r30
 b8c:	ff 1f       	adc	r31, r31
 b8e:	ee 0f       	add	r30, r30
 b90:	ff 1f       	adc	r31, r31
 b92:	ee 0f       	add	r30, r30
 b94:	ff 1f       	adc	r31, r31
 b96:	8e 0f       	add	r24, r30
 b98:	9f 1f       	adc	r25, r31
 b9a:	fc 01       	movw	r30, r24
 b9c:	ee 5f       	subi	r30, 0xFE	; 254
 b9e:	fc 4f       	sbci	r31, 0xFC	; 252
 ba0:	80 81       	ld	r24, Z
 ba2:	88 23       	and	r24, r24
 ba4:	49 f3       	breq	.-46     	; 0xb78 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 ba6:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <uxTopReadyPriority>
 baa:	90 e0       	ldi	r25, 0x00	; 0
 bac:	9c 01       	movw	r18, r24
 bae:	22 0f       	add	r18, r18
 bb0:	33 1f       	adc	r19, r19
 bb2:	22 0f       	add	r18, r18
 bb4:	33 1f       	adc	r19, r19
 bb6:	22 0f       	add	r18, r18
 bb8:	33 1f       	adc	r19, r19
 bba:	28 0f       	add	r18, r24
 bbc:	39 1f       	adc	r19, r25
 bbe:	d9 01       	movw	r26, r18
 bc0:	ae 5f       	subi	r26, 0xFE	; 254
 bc2:	bc 4f       	sbci	r27, 0xFC	; 252
 bc4:	11 96       	adiw	r26, 0x01	; 1
 bc6:	ed 91       	ld	r30, X+
 bc8:	fc 91       	ld	r31, X
 bca:	12 97       	sbiw	r26, 0x02	; 2
 bcc:	02 80       	ldd	r0, Z+2	; 0x02
 bce:	f3 81       	ldd	r31, Z+3	; 0x03
 bd0:	e0 2d       	mov	r30, r0
 bd2:	12 96       	adiw	r26, 0x02	; 2
 bd4:	fc 93       	st	X, r31
 bd6:	ee 93       	st	-X, r30
 bd8:	11 97       	sbiw	r26, 0x01	; 1
 bda:	2b 5f       	subi	r18, 0xFB	; 251
 bdc:	3c 4f       	sbci	r19, 0xFC	; 252
 bde:	e2 17       	cp	r30, r18
 be0:	f3 07       	cpc	r31, r19
 be2:	29 f4       	brne	.+10     	; 0xbee <vTaskSwitchContext+0xac>
 be4:	22 81       	ldd	r18, Z+2	; 0x02
 be6:	33 81       	ldd	r19, Z+3	; 0x03
 be8:	fd 01       	movw	r30, r26
 bea:	32 83       	std	Z+2, r19	; 0x02
 bec:	21 83       	std	Z+1, r18	; 0x01
 bee:	fc 01       	movw	r30, r24
 bf0:	ee 0f       	add	r30, r30
 bf2:	ff 1f       	adc	r31, r31
 bf4:	ee 0f       	add	r30, r30
 bf6:	ff 1f       	adc	r31, r31
 bf8:	ee 0f       	add	r30, r30
 bfa:	ff 1f       	adc	r31, r31
 bfc:	8e 0f       	add	r24, r30
 bfe:	9f 1f       	adc	r25, r31
 c00:	fc 01       	movw	r30, r24
 c02:	ee 5f       	subi	r30, 0xFE	; 254
 c04:	fc 4f       	sbci	r31, 0xFC	; 252
 c06:	01 80       	ldd	r0, Z+1	; 0x01
 c08:	f2 81       	ldd	r31, Z+2	; 0x02
 c0a:	e0 2d       	mov	r30, r0
 c0c:	86 81       	ldd	r24, Z+6	; 0x06
 c0e:	97 81       	ldd	r25, Z+7	; 0x07
 c10:	90 93 30 03 	sts	0x0330, r25	; 0x800330 <pxCurrentTCB+0x1>
 c14:	80 93 2f 03 	sts	0x032F, r24	; 0x80032f <pxCurrentTCB>
 c18:	08 95       	ret

00000c1a <memset>:
 c1a:	dc 01       	movw	r26, r24
 c1c:	01 c0       	rjmp	.+2      	; 0xc20 <memset+0x6>
 c1e:	6d 93       	st	X+, r22
 c20:	41 50       	subi	r20, 0x01	; 1
 c22:	50 40       	sbci	r21, 0x00	; 0
 c24:	e0 f7       	brcc	.-8      	; 0xc1e <memset+0x4>
 c26:	08 95       	ret

00000c28 <strncpy>:
 c28:	fb 01       	movw	r30, r22
 c2a:	dc 01       	movw	r26, r24
 c2c:	41 50       	subi	r20, 0x01	; 1
 c2e:	50 40       	sbci	r21, 0x00	; 0
 c30:	48 f0       	brcs	.+18     	; 0xc44 <strncpy+0x1c>
 c32:	01 90       	ld	r0, Z+
 c34:	0d 92       	st	X+, r0
 c36:	00 20       	and	r0, r0
 c38:	c9 f7       	brne	.-14     	; 0xc2c <strncpy+0x4>
 c3a:	01 c0       	rjmp	.+2      	; 0xc3e <strncpy+0x16>
 c3c:	1d 92       	st	X+, r1
 c3e:	41 50       	subi	r20, 0x01	; 1
 c40:	50 40       	sbci	r21, 0x00	; 0
 c42:	e0 f7       	brcc	.-8      	; 0xc3c <strncpy+0x14>
 c44:	08 95       	ret

00000c46 <_exit>:
 c46:	f8 94       	cli

00000c48 <__stop_program>:
 c48:	ff cf       	rjmp	.-2      	; 0xc48 <__stop_program>
